typedef enum { KX_HM_STATE_EMPTY, KX_HM_STATE_OCCUPIED, KX_HM_STATE_DELETED } StrU64Map_EntryState; typedef struct { str key; u64 value; StrU64Map_EntryState state; } StrU64Map_Entry; typedef struct { StrU64Map_Entry *entries; usize capacity; usize count; SystemAlloc *allocer; } StrU64Map; typedef struct Option_StrU64Map_V { OptionKind kind; union { u64 some; } value; } Option_StrU64Map_V; typedef struct Option_StrU64Map_V_Ptr { OptionKind kind; union { u64 * some; } value; } Option_StrU64Map_V_Ptr; static const f64 StrU64Map_LOAD_FACTOR = 0.75; static const usize StrU64Map_DEFAULT_CAPACITY = 64; static inline void StrU64Map_init_entries( StrU64Map_Entry *entries, usize capacity) { for (usize i = 0; i < capacity; i++) { entries[i].state = KX_HM_STATE_EMPTY; } } typedef struct { usize index; bool found; } StrU64Map_FindResult; static inline StrU64Map_FindResult StrU64Map_find_entry( StrU64Map_Entry *entries, usize capacity, const str *key) { if (capacity == 0) { return (StrU64Map_FindResult){0, false}; } u64 hash = kx_hash_fn_str(key); usize base_index = (usize)(hash % (u64)capacity); usize first_tombstone = capacity; for (usize i = 0; i < capacity; i++) { usize index = (base_index + i) % capacity; StrU64Map_Entry *entry = &entries[index]; switch (entry->state) { case KX_HM_STATE_EMPTY: if (first_tombstone != capacity) { return (StrU64Map_FindResult){first_tombstone, false}; } else { return (StrU64Map_FindResult){index, false}; } case KX_HM_STATE_OCCUPIED: if (kx_cmp_fn_str(&entry->key, key)) { return (StrU64Map_FindResult){index, true}; } break; case KX_HM_STATE_DELETED: if (first_tombstone == capacity) { first_tombstone = index; } break; } } return (StrU64Map_FindResult){first_tombstone, false}; } static inline bool StrU64Map_resize(StrU64Map *self); static inline void StrU64Map_write_at(StrU64Map *self, usize index, str key, u64 value, bool is_new) { if (is_new) { do { if (!(self->entries[index].state != KX_HM_STATE_OCCUPIED)) { do { vformat_func((void *)(stderr), file_sink_push_char_adapter, file_sink_push_bytes_adapter, ("{}[PANIC] ({}:{}) " "Assertion failed (`{}`): " "Writing new key to occupied slot" "{}\n"), (0 +5) , _Generic((fg(((Color24){(u8)(255), (u8)(80), (u8)(80)}))), i8: 1, i16: 2, i32: 3, i64: 4, u8: 5, u16: 6, u32: 7, u64: 8, float: 9, double: 10, str: 11, char *: 12, char: 13, void *: 14, default: 0), (fg(((Color24){(u8)(255), (u8)(80), (u8)(80)}))), _Generic(("tests/test_hashmap.c"), i8: 1, i16: 2, i32: 3, i64: 4, u8: 5, u16: 6, u32: 7, u64: 8, float: 9, double: 10, str: 11, char *: 12, char: 13, void *: 14, default: 0), ("tests/test_hashmap.c"), _Generic((20), i8: 1, i16: 2, i32: 3, i64: 4, u8: 5, u16: 6, u32: 7, u64: 8, float: 9, double: 10, str: 11, char *: 12, char: 13, void *: 14, default: 0), (20), _Generic(("self->entries[index].state != KX_HM_STATE_OCCUPIED"), i8: 1, i16: 2, i32: 3, i64: 4, u8: 5, u16: 6, u32: 7, u64: 8, float: 9, double: 10, str: 11, char *: 12, char: 13, void *: 14, default: 0), ("self->entries[index].state != KX_HM_STATE_OCCUPIED"), _Generic((reset()), i8: 1, i16: 2, i32: 3, i64: 4, u8: 5, u16: 6, u32: 7, u64: 8, float: 9, double: 10, str: 11, char *: 12, char: 13, void *: 14, default: 0), (reset())); abort(); } while (0); } } while (0); self->count++; } else { do { if (!(self->entries[index].state == KX_HM_STATE_OCCUPIED)) { do { vformat_func((void *)(stderr), file_sink_push_char_adapter, file_sink_push_bytes_adapter, ("{}[PANIC] ({}:{}) " "Assertion failed (`{}`): " "Updating value of non-occupied slot" "{}\n"), (0 +5) , _Generic((fg(((Color24){(u8)(255), (u8)(80), (u8)(80)}))), i8: 1, i16: 2, i32: 3, i64: 4, u8: 5, u16: 6, u32: 7, u64: 8, float: 9, double: 10, str: 11, char *: 12, char: 13, void *: 14, default: 0), (fg(((Color24){(u8)(255), (u8)(80), (u8)(80)}))), _Generic(("tests/test_hashmap.c"), i8: 1, i16: 2, i32: 3, i64: 4, u8: 5, u16: 6, u32: 7, u64: 8, float: 9, double: 10, str: 11, char *: 12, char: 13, void *: 14, default: 0), ("tests/test_hashmap.c"), _Generic((20), i8: 1, i16: 2, i32: 3, i64: 4, u8: 5, u16: 6, u32: 7, u64: 8, float: 9, double: 10, str: 11, char *: 12, char: 13, void *: 14, default: 0), (20), _Generic(("self->entries[index].state == KX_HM_STATE_OCCUPIED"), i8: 1, i16: 2, i32: 3, i64: 4, u8: 5, u16: 6, u32: 7, u64: 8, float: 9, double: 10, str: 11, char *: 12, char: 13, void *: 14, default: 0), ("self->entries[index].state == KX_HM_STATE_OCCUPIED"), _Generic((reset()), i8: 1, i16: 2, i32: 3, i64: 4, u8: 5, u16: 6, u32: 7, u64: 8, float: 9, double: 10, str: 11, char *: 12, char: 13, void *: 14, default: 0), (reset())); abort(); } while (0); } } while (0); } self->entries[index].key = key; self->entries[index].value = value; self->entries[index].state = KX_HM_STATE_OCCUPIED; } static inline StrU64Map *StrU64Map_new(SystemAlloc *allocer) { StrU64Map *self = kx_SystemAlloc_alloc_type(allocer, StrU64Map); if (self == ((void*)0)) { return ((void*)0); } usize init_cap = StrU64Map_DEFAULT_CAPACITY; Layout layout = kx_layout_array(sizeof(StrU64Map_Entry), init_cap); void *ptr = kx_SystemAlloc_alloc(allocer, layout); if (ptr == ((void*)0)) { kx_SystemAlloc_delete_type(allocer, self, StrU64Map); return ((void*)0); } self->entries = (StrU64Map_Entry *)ptr; self->capacity = init_cap; self->count = 0; self->allocer = allocer; StrU64Map_init_entries(self->entries, init_cap); return self; } static inline void StrU64Map_free(StrU64Map *self) { if (self == ((void*)0)) { return; } Layout layout = kx_layout_array( sizeof(StrU64Map_Entry), self->capacity); kx_SystemAlloc_release( self->allocer, self->entries, layout); kx_SystemAlloc_delete_type( self->allocer, self, StrU64Map); } static inline void StrU64Map_put( StrU64Map *self, str key, u64 value) { StrU64Map_FindResult res = StrU64Map_find_entry( self->entries, self->capacity, &key); if (res.found) { StrU64Map_write_at( self, res.index, key, value, false); return; } bool needs_resize = (res.index == self->capacity) || ((f64)(self->count + 1) > (f64)self->capacity * StrU64Map_LOAD_FACTOR); if (needs_resize) { if (!StrU64Map_resize(self)) { do { if (!(false)) { do { vformat_func((void *)(stderr), file_sink_push_char_adapter, file_sink_push_bytes_adapter, ("{}[PANIC] ({}:{}) " "Assertion failed (`{}`): " "HashMap resize failed (OOM)" "{}\n"), (0 +5) , _Generic((fg(((Color24){(u8)(255), (u8)(80), (u8)(80)}))), i8: 1, i16: 2, i32: 3, i64: 4, u8: 5, u16: 6, u32: 7, u64: 8, float: 9, double: 10, str: 11, char *: 12, char: 13, void *: 14, default: 0), (fg(((Color24){(u8)(255), (u8)(80), (u8)(80)}))), _Generic(("tests/test_hashmap.c"), i8: 1, i16: 2, i32: 3, i64: 4, u8: 5, u16: 6, u32: 7, u64: 8, float: 9, double: 10, str: 11, char *: 12, char: 13, void *: 14, default: 0), ("tests/test_hashmap.c"), _Generic((20), i8: 1, i16: 2, i32: 3, i64: 4, u8: 5, u16: 6, u32: 7, u64: 8, float: 9, double: 10, str: 11, char *: 12, char: 13, void *: 14, default: 0), (20), _Generic(("false"), i8: 1, i16: 2, i32: 3, i64: 4, u8: 5, u16: 6, u32: 7, u64: 8, float: 9, double: 10, str: 11, char *: 12, char: 13, void *: 14, default: 0), ("false"), _Generic((reset()), i8: 1, i16: 2, i32: 3, i64: 4, u8: 5, u16: 6, u32: 7, u64: 8, float: 9, double: 10, str: 11, char *: 12, char: 13, void *: 14, default: 0), (reset())); abort(); } while (0); } } while (0); return; } res = StrU64Map_find_entry( self->entries, self->capacity, &key); do { if (!(!res.found)) { do { vformat_func((void *)(stderr), file_sink_push_char_adapter, file_sink_push_bytes_adapter, ("{}[PANIC] ({}:{}) " "Assertion failed (`{}`): " "Key found immediately after resize" "{}\n"), (0 +5) , _Generic((fg(((Color24){(u8)(255), (u8)(80), (u8)(80)}))), i8: 1, i16: 2, i32: 3, i64: 4, u8: 5, u16: 6, u32: 7, u64: 8, float: 9, double: 10, str: 11, char *: 12, char: 13, void *: 14, default: 0), (fg(((Color24){(u8)(255), (u8)(80), (u8)(80)}))), _Generic(("tests/test_hashmap.c"), i8: 1, i16: 2, i32: 3, i64: 4, u8: 5, u16: 6, u32: 7, u64: 8, float: 9, double: 10, str: 11, char *: 12, char: 13, void *: 14, default: 0), ("tests/test_hashmap.c"), _Generic((20), i8: 1, i16: 2, i32: 3, i64: 4, u8: 5, u16: 6, u32: 7, u64: 8, float: 9, double: 10, str: 11, char *: 12, char: 13, void *: 14, default: 0), (20), _Generic(("!res.found"), i8: 1, i16: 2, i32: 3, i64: 4, u8: 5, u16: 6, u32: 7, u64: 8, float: 9, double: 10, str: 11, char *: 12, char: 13, void *: 14, default: 0), ("!res.found"), _Generic((reset()), i8: 1, i16: 2, i32: 3, i64: 4, u8: 5, u16: 6, u32: 7, u64: 8, float: 9, double: 10, str: 11, char *: 12, char: 13, void *: 14, default: 0), (reset())); abort(); } while (0); } } while (0); do { if (!(res.index < self->capacity)) { do { vformat_func((void *)(stderr), file_sink_push_char_adapter, file_sink_push_bytes_adapter, ("{}[PANIC] ({}:{}) " "Assertion failed (`{}`): " "No insert slot found after resize" "{}\n"), (0 +5) , _Generic((fg(((Color24){(u8)(255), (u8)(80), (u8)(80)}))), i8: 1, i16: 2, i32: 3, i64: 4, u8: 5, u16: 6, u32: 7, u64: 8, float: 9, double: 10, str: 11, char *: 12, char: 13, void *: 14, default: 0), (fg(((Color24){(u8)(255), (u8)(80), (u8)(80)}))), _Generic(("tests/test_hashmap.c"), i8: 1, i16: 2, i32: 3, i64: 4, u8: 5, u16: 6, u32: 7, u64: 8, float: 9, double: 10, str: 11, char *: 12, char: 13, void *: 14, default: 0), ("tests/test_hashmap.c"), _Generic((20), i8: 1, i16: 2, i32: 3, i64: 4, u8: 5, u16: 6, u32: 7, u64: 8, float: 9, double: 10, str: 11, char *: 12, char: 13, void *: 14, default: 0), (20), _Generic(("res.index < self->capacity"), i8: 1, i16: 2, i32: 3, i64: 4, u8: 5, u16: 6, u32: 7, u64: 8, float: 9, double: 10, str: 11, char *: 12, char: 13, void *: 14, default: 0), ("res.index < self->capacity"), _Generic((reset()), i8: 1, i16: 2, i32: 3, i64: 4, u8: 5, u16: 6, u32: 7, u64: 8, float: 9, double: 10, str: 11, char *: 12, char: 13, void *: 14, default: 0), (reset())); abort(); } while (0); } } while (0); } StrU64Map_write_at(self, res.index, key, value, true); } static inline bool StrU64Map_resize(StrU64Map *self) { StrU64Map_Entry *old_entries = self->entries; usize old_capacity = self->capacity; usize new_capacity = (old_capacity == 0) ? StrU64Map_DEFAULT_CAPACITY : old_capacity * 2; Layout new_layout = kx_layout_array( sizeof(StrU64Map_Entry), new_capacity); StrU64Map_Entry *new_entries = (StrU64Map_Entry *)kx_SystemAlloc_alloc(self->allocer, new_layout); if (new_entries == ((void*)0)) { return false; } StrU64Map_init_entries(new_entries, new_capacity); self->entries = new_entries; self->capacity = new_capacity; self->count = 0; for (usize i = 0; i < old_capacity; i++) { StrU64Map_Entry *entry = &old_entries[i]; if (entry->state == KX_HM_STATE_OCCUPIED) { StrU64Map_FindResult res = StrU64Map_find_entry( self->entries, self->capacity, &entry->key); do { if (!(!res.found && res.index < self->capacity)) { do { vformat_func((void *)(stderr), file_sink_push_char_adapter, file_sink_push_bytes_adapter, ("{}[PANIC] ({}:{}) " "Assertion failed (`{}`): " "Resize re-hash failed" "{}\n"), (0 +5) , _Generic((fg(((Color24){(u8)(255), (u8)(80), (u8)(80)}))), i8: 1, i16: 2, i32: 3, i64: 4, u8: 5, u16: 6, u32: 7, u64: 8, float: 9, double: 10, str: 11, char *: 12, char: 13, void *: 14, default: 0), (fg(((Color24){(u8)(255), (u8)(80), (u8)(80)}))), _Generic(("tests/test_hashmap.c"), i8: 1, i16: 2, i32: 3, i64: 4, u8: 5, u16: 6, u32: 7, u64: 8, float: 9, double: 10, str: 11, char *: 12, char: 13, void *: 14, default: 0), ("tests/test_hashmap.c"), _Generic((20), i8: 1, i16: 2, i32: 3, i64: 4, u8: 5, u16: 6, u32: 7, u64: 8, float: 9, double: 10, str: 11, char *: 12, char: 13, void *: 14, default: 0), (20), _Generic(("!res.found && res.index < self->capacity"), i8: 1, i16: 2, i32: 3, i64: 4, u8: 5, u16: 6, u32: 7, u64: 8, float: 9, double: 10, str: 11, char *: 12, char: 13, void *: 14, default: 0), ("!res.found && res.index < self->capacity"), _Generic((reset()), i8: 1, i16: 2, i32: 3, i64: 4, u8: 5, u16: 6, u32: 7, u64: 8, float: 9, double: 10, str: 11, char *: 12, char: 13, void *: 14, default: 0), (reset())); abort(); } while (0); } } while (0); StrU64Map_write_at(self, res.index, entry->key, entry->value, true); } } Layout old_layout = kx_layout_array( sizeof(StrU64Map_Entry), old_capacity); kx_SystemAlloc_release( self->allocer, old_entries, old_layout); return true; } static inline StrU64Map_V_Ptr StrU64Map_get_ptr( StrU64Map *self, const str *key) { StrU64Map_FindResult res = StrU64Map_find_entry( self->entries, self->capacity, key); if (res.found) { return (Option_StrU64Map_V_Ptr) { .kind = SOME, .value = {.some = &self->entries[res.index].value } }; } else { return (Option_StrU64Map_V_Ptr) { .kind = NONE }; } } static inline StrU64Map_V StrU64Map_get(StrU64Map *self, const str *key) { StrU64Map_FindResult res = StrU64Map_find_entry( self->entries, self->capacity, key); if (res.found) { return (Option_StrU64Map_V) { .kind = SOME, .value = {.some = self->entries[res.index].value } }; } else { return (Option_StrU64Map_V) { .kind = NONE }; } } static inline bool StrU64Map_delete(StrU64Map *self, const str *key) { StrU64Map_FindResult res = StrU64Map_find_entry( self->entries, self->capacity, key); if (!res.found) { return false; } self->entries[res.index].state = KX_HM_STATE_DELETED; self->count--; return true; };

